<!DOCTYPE html>
<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hevea 2.32">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.titlemain{margin:1ex 2ex 2ex 1ex;}
.titlerest{margin:0ex 2ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</style>
<title>proj1</title>
</head>
<body >
<!--HEVEA command line is: hevea proj1.tex -->
<!--CUT STYLE article--><!--CUT DEF section 1 --><div class="center">
<span style="font-variant:small-caps"><span style="font-size:large">The University of Melbourne
</span></span> <br>
 <span style="font-size:large">School of Computing and Information Systems
</span> <br>
 <span style="font-size:x-large">Declarative Programming
</span> <br>
 <span style="font-size:large">COMP30020
</span> <br>
 <span style="font-size:large">Semester 2, 2018
</span> <br>
 <span style="font-weight:bold"><span style="font-size:x-large">Project Specification</span></span> <br>
 <span style="font-size:large"><em>Project due 
Monday, 3 September 2018, 5:00PM</em></span> <br>
 <span style="font-size:large"><em>Worth
15%</em></span>
</div><p><br>
<br>
<br>
</p><p>The objective of this project is to practice and assess your
understanding of functional programming and Haskell. You will write code to
implement the guessing part of a logical guessing game.</p><!--TOC section id="sec1" The Game-->
<h2 id="sec1" class="section">The Game</h2><!--SEC END --><p>There has been a daring daylight robbery committed by a pair of
audacious criminals.
Your program&#X2019;s job is to identify the criminals on the basis of the
observations of three eyewitnesses.
You&#X2019;ve assembled a dozen of the usual suspects and now must work out which pair
of them are the culprits.
You will do this by putting them in lineups
in pairs, asking your witnesses to indicate whether
you have identified the culprits.</p><p>Each eyewitness, though, has a hazy memory, and each mostly only focused
on one aspect of the culprits&#X2019; appearance.
The first witness mostly paid attention to the height of the perpetrators
(whether <em>Short</em> or <em>Tall</em>);
the second only took note of their hair colour
(whether <em>Blond(e)</em>, <em>Redhead</em>, or <em>Dark haired</em>);
and the third only noticed gender (<em>Male</em> or <em>Female</em>).
The witnesses are not able to describe the perpetrators, they can only recognise
them when they see them, and recognise whether they have the characteristics
they observed at the time of the crime.</p><p>You can put pairs of people in a lineup as many times as necessary, and may
include the same person in a lineup multiple times.
For each lineup, your witnesses will tell you how many in the lineup are the
people they saw committing the crime, as well as how many of them have the right
height, how many have the right hair colour, and how many are of the right sex.
Each lineup must have exactly two different people, and the order of people in
the lineup is not significant.</p><p>Once the witnesses agree that both people in the lineup are guilty,
your job is finished and you can charge the culprits.
Naturally, the police chief is keen for you to do this as soon as
possible.</p><p>For simplicity, we will identify each suspect by their characteristics, as a
three letter identifier.
The first letter indicates the height, either <span style="font-family:monospace">S</span> or <span style="font-family:monospace">T</span>.
The second indicates hair colour, either <span style="font-family:monospace">B</span>, <span style="font-family:monospace">R</span> or <span style="font-family:monospace">D</span>.
The third specifies sex, either <span style="font-family:monospace">M</span> or <span style="font-family:monospace">F</span>.
The feedback you receive from the witnesses comprise four numbers:
the number of culprits you have identified, the number in the lineup with the
right height, the number with the right hair colour, and the number with the
right sex.</p><p>In counting the number with the correct characteristics, we can only count
each person (and each culprit) once. For example, if the lineup has two males
and only one of the culprits were male, that is counted as one correct sex.
Likewise, if the lineup has one male and one female, but both culprits were
male, that also counts as one correct sex.
Also note that if one of the suspects in the lineup is identified as a culprit,
that person is not counted in the number of correct heights, hair colours, and
sexes.</p><p>Here are a few examples:
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-weight:bold">Culprit</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-weight:bold">Lineup</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-weight:bold">Answer</span> </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <em>SBM, SBF</em></td><td style="text-align:center;white-space:nowrap" ><em>SBM, TRF</em></td><td style="text-align:center;white-space:nowrap" >(1,0,0,1) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <em>SBM, SBF</em></td><td style="text-align:center;white-space:nowrap" ><em>TRF, SBM</em></td><td style="text-align:center;white-space:nowrap" >(1,0,0,1) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <em>SBM, SBF</em></td><td style="text-align:center;white-space:nowrap" ><em>TRF, TRM</em></td><td style="text-align:center;white-space:nowrap" >(0,0,0,2) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <em>SBM, TDF</em></td><td style="text-align:center;white-space:nowrap" ><em>TRF, SDM</em></td><td style="text-align:center;white-space:nowrap" >(0,2,1,2) </td></tr>
</table>
</div><!--TOC section id="sec2" The Program-->
<h2 id="sec2" class="section">The Program</h2><!--SEC END --><p>
You will write Haskell code to determine which suspects to include in each
lineup.
Each lineup constitutes a &#X201C;guess&#X201D; as to which pair of suspects are
the perpetrators, for which your program will receive feedback.
This will require you to write a function to return your
initial lineup, and another to use the feedback from the previous lineup
to determine the next one. The former function will be called once per game,
and then the latter function will be called
repeatedly until it produces the correct lineup. You will find it
useful to keep information between guesses; since Haskell is a purely
functional language, you cannot use a global or static variable to
store this. Therefore, your initial guess function must return this
game state information, and your next guess function must take the
game state as input and return a new game state as output. You
may put any information you like in the game state, but you
<span style="font-style:italic">must</span> define a type <span style="font-family:monospace">GameState</span> to hold this
information. If you do not need to maintain any game state, you may
simply define <span style="font-family:monospace">type GameState = ()</span>.</p><p>You may use any representation you like for suspects, but you must
define a type <span style="font-family:monospace">Person</span> to hold your representation.
The quality of your design is one assessment criterion for this project,
so take care to choose (and document!) a good design.
You must also define a function <span style="font-family:monospace">parsePerson</span> to convert a three-letter
string of the form above into a <span style="font-family:monospace">Person</span>.
You must also define functions <span style="font-family:monospace">height</span>, <span style="font-family:monospace">hair</span>, and <span style="font-family:monospace">sex</span>
to return the height, hair colour, and sex of a <span style="font-family:monospace">Person</span>.
You may represent height, hair colour, and sex any way you like, as long
as the types are in the <span style="font-family:monospace">Eq</span> class.</p><p>You must also write a function <span style="font-family:monospace">initialGuess</span> to return your first guess,
and <span style="font-family:monospace">nextGuess</span> to return your next guess given the results of your
previous one.</p><p>Here is a summary of the types you must define:
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">Person</span></dt><dd class="dd-description"> Represents a suspect
</dd><dt class="dt-description"><span style="font-weight:bold">GameState</span></dt><dd class="dd-description"> holds whatever information you need to help decide your next
guess based on the previous one.
</dd></dl><p>Here is a summary of the functions you must define:
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">parsePerson :: String </span>&#X2192;<span style="font-weight:bold"> Maybe Person</span></dt><dd class="dd-description">  <br>
 takes a three-character string and returns <span style="font-family:monospace">Just</span> <em>p</em>,
where <em>p</em> is the person specified by that string. If an invalid string
is provided, returns <span style="font-family:monospace">Nothing</span>.
</dd><dt class="dt-description"><span style="font-weight:bold">height :: Person </span>&#X2192;<span style="font-weight:bold"> </span><span style="font-weight:bold"><em>whatever you like</em></span></dt><dd class="dd-description">  <br>
 Returns the person&#X2019;s height, represented as any type in the <em>Eq</em> class.
</dd><dt class="dt-description"><span style="font-weight:bold">hair :: Person </span>&#X2192;<span style="font-weight:bold"> </span><span style="font-weight:bold"><em>whatever you like</em></span></dt><dd class="dd-description">  <br>
 Returns the person&#X2019;s hair colour, represented as any type in the <em>Eq</em>
class.
</dd><dt class="dt-description"><span style="font-weight:bold">sex :: Person </span>&#X2192;<span style="font-weight:bold"> </span><span style="font-weight:bold"><em>whatever you like</em></span></dt><dd class="dd-description">  <br>
 Returns the person&#X2019;s sex, represented as any type in the <em>Eq</em> class.
</dd><dt class="dt-description"><span style="font-weight:bold">feedback :: [Person] </span>&#X2192;<span style="font-weight:bold"> [Person] </span>&#X2192;<span style="font-weight:bold"> (Int,Int,Int,Int)</span></dt><dd class="dd-description">  <br>
 Takes first a list of the true culprits and second a list of the
suspects in your lineup, and returns a quadruple of correct suspects,
correct heights, correct hair colours, and correct sexes, in that order.
</dd><dt class="dt-description"><span style="font-weight:bold">initialGuess :: ([Person],GameState)</span></dt><dd class="dd-description">  <br>
 Returns your initial lineup and initial game state.
</dd><dt class="dt-description"><span style="font-weight:bold">nextGuess :: ([Person],GameState) </span>&#X2192;<span style="font-weight:bold"> (Int,Int,Int,Int)
</span>&#X2192;<span style="font-weight:bold"> ([Person],GameState)</span></dt><dd class="dd-description">  <br>
 takes as input a pair of the previous guess and game state (as returned by
<span style="font-family:monospace">initialGuess</span> and <span style="font-family:monospace">nextGuess</span>), and
the feedback to this guess as a quadruple of correct suspects,
correct height, correct hair colour, and correct sex, in that order,
and returns a pair of the next guess and new game state.
</dd></dl><p>You must call your source file <span style="font-family:monospace">Proj1.hs</span> (or
<span style="font-family:monospace">Proj1.lhs</span> if you use literate Haskell),
and it must begin with the module declaration:
</p><pre>
module Proj1 (Person, parsePerson, height, hair, sex,
              GameState, initialGuess, nextGuess, feedback) where
</pre><p>
(after any initial documentation comments).
Please put all your code in this one file.</p><p>I will post a test driver program <span style="font-family:monospace">Proj1Test.hs</span>,
which will operate similarly to how I actually test
your code. I will compile
and link your code for testing using the command:
</p><pre>
    ghc -O2 --make Proj1Test
</pre><p>
or similar.
To run <span style="font-family:monospace">Proj1Test</span>, give it the target as two separate
command line arguments, for example <span style="font-family:monospace">./Proj1Test TBM SRF</span>
would run your code setting the actual culprits as a tall blond male and a short
redhead female.
It will then use your <span style="font-family:monospace">Proj1</span> module to
assemble lineups, showing you all your program&#X2019;s lineup selections
and tell you how many guesses your program took to guess the culprits.
</p><pre class="verbatim">Your guess 1:  SBM SRM
My answer:  (0,1,2,1)
Your guess 2:  SBF TRM
My answer:  (0,2,2,2)
Your guess 3:  SRF TBM
My answer:  (2,0,0,0)
You got it in 3 guesses!
</pre><!--TOC section id="sec3" Assessment-->
<h2 id="sec3" class="section">Assessment</h2><!--SEC END --><p>Your project will be assessed on the following criteria:</p><ul class="itemize"><li class="li-itemize">
10% Correctness of your <span style="font-family:monospace">feedback</span> implementation;
</li><li class="li-itemize">10% Correctness of your <span style="font-family:monospace">initialGuess</span> and <span style="font-family:monospace">nextGuess</span>
implementations;
</li><li class="li-itemize">50% Quality of your implementation;
</li><li class="li-itemize">30% Quality of your code and documentation
</li></ul><p>The correctness of your <span style="font-family:monospace">feedback</span> function will be assessed based on the
proportion of test cases it passes.
The correctness of your <span style="font-family:monospace">initialGuess</span> and <span style="font-family:monospace">nextGuess</span> functions
will be assessed based on whether it succeeds in guessing the culprits in
the available time.
The correctness of other functions will not be explicitly tested, but will be
necessary to the correct functioning of all the tests.</p><p>The quality of your implementation will be assessed based on the number of
guesses needed to find the given targets.
All possible culprit pairs will be tested;
full marks will be given for an average of 2.7 guesses or fewer per target,
with marks falling on a logarithmic scale as the number of guesses
rises.</p><p>Note that timeouts will be imposed on all tests. You will have at least 2
seconds to guess each target, regardless of how many guesses are needed.
Executions taking longer than that may be unceremoniously terminated,
leading to that test being assessed as failing. Your programs will be
compiled with <span style="font-family:monospace">GHC -O2</span> before testing, so 2 seconds per test
is a very reasonable limit (it should be 100 times more than you need).</p><p>The quality of your code will be assessed based on appropriate use of Haskell,
including the design of your data types, as well as on overall
(language-independent) good coding and documentation practices.
See the Project Coding Guidelines on the LMS for detailed suggestions
for coding and documentation style.
This is worth a substantial fraction of your project mark; an hour cleaning up
and documenting your code before your final submission will be well rewarded.</p><!--TOC section id="sec4" Submission-->
<h2 id="sec4" class="section">Submission</h2><!--SEC END --><p>You must submit your project through the <span style="font-family:sans-serif">Maat</span> (Melbourne Automated
Appraisal Tool) system by following the link from the LMS Projects page
using your web browser.
You may drag-and-drop your file onto the box for your Proj1.hs
file, or click the &#X201C;Choose&#X201D; button and use your browser&#X2019;s file selection
dialog. Either way, once you have provided your file, click the &#X201C;Save
Submission&#X201D; button to submit.</p><p><span style="font-weight:bold">Important:</span> you must wait while <span style="font-family:sans-serif">Maat</span> tests your code.
Once it has completed the appraisal, the window will refresh to show the
test results.
If any tests fail, the display will show which of the tests failed,
but you will not see the inputs for the failing test case, so you will
need to revisit your code, and reexamine this project specification,
to try to see what is wrong with your code.</p><p><span style="font-weight:bold">It is your responsibility to look over the feedback provided
for your submission.</span></p><p>If the test results show any problems, you may correct your code
and submit again. You may submit as often as you like; only your
final submission will be assessed.</p><!--TOC subsection id="sec5" Late Penalties-->
<h3 id="sec5" class="subsection">Late Penalties</h3><!--SEC END --><p>
Late submissions will incur a penalty of 0.5% of the possible value of that
submission per hour 
late, including evening and weekend hours.
This means that a perfect
project that is much more than 4 days late will receive less than half
the marks for the project. If you have a
medical or similar compelling reason for being late, you should contact 
the lecturer
as early as possible to ask for an extension
(preferably before the due date).</p><!--TOC section id="sec6" Hints-->
<h2 id="sec6" class="section">Hints</h2><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">
A very simple approach to this program is to simply guess every
possible pair of persons until you guess right. There are
only 66 distinct pairs, so on average it should only take about
33 lineups, making it perfectly feasible to do in 2 seconds.
However, this will give a poor score for guess quality.</li><li class="li-enumerate">A better approach would be only to select lineups that are
consistent with the answers you have received for previous lineups.
You can do this by computing the list of all possible lineups, and
removing elements that are inconsistent with any answers you have
received to previous lineups. A possible target is inconsistent
with an answer you have received for a previous lineup if the answer
you would receive for that lineup and that (possible) pair of culprits is
different from the answer you actually received for that lineup.<p>You can use your <span style="font-family:monospace">GameState</span> type to store your previous
lineups and the corresponding answers. Or, more efficient and just
as easy, store the list of remaining possible targets in your
<span style="font-family:monospace">GameState</span>, and pare it down each time you receive
feedback for a lineup.
Using this approach should give you about 80% of the marks for lineup
quality.</p></li><li class="li-enumerate">To get full marks for guess quality, you will need to 
carefully choose each lineup so
that it is most likely to leave a small remaining list of possible lineups.
This you can do by computing, for each remaining possible lineup,
the answer you will receive if it is the actual lineup, and then
compute how many of the remaining possible lineups would yield the
same output, and compute the
<em>average</em> number of possible lineups that will remain after
each lineup, giving the <em>expected</em> number of remaining possible
lineups for each guess, and choose the lineup with the smallest
expected number of remaining possible lineups.<p>For example, suppose there are ten remaining candidate lineups, and one
lineup gives the answer (2,0,0,0), three others give (1,0,1,1), and the
remaining six give the answer (0,1,1,2).
In this case, if you make that guess, there is a 1 in 10 chance of that
being the right answer (so you are left with that as the only remaining
candidate), 3 in 10 of being left with three candidates, and a 6 in 10
chance of being left with six candidates.
This means on average you would expect this answer to leave you with
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell">&#XA0;&#XD7;&#XA0;1&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">3</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell">&#XA0;&#XD7;&#XA0;3&#XA0;+&#XA0;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">6</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell">&#XA0;&#XD7;&#XA0;6</td></tr>
</table></td><td class="dcell">&#XA0;=&#XA0;4.6
</td></tr>
</table><p>
remaining candidates.
You can perform a similar computation for every possible lineup,
and select a lineup that gives the minimum expected number
of remaining candidates.</p><p>Also note that if you do this incorrectly, the worst consequence is
that your program takes more lineups than necessary to find the
lineup. As long as you only ever guess a possible lineup,
every guess other than the right one removes at least one possible lineup,
so you will eventually guess the right lineup.</p></li><li class="li-enumerate">Do feel free to discuss the hints on the discussion forum, and to share
overall strategy. If you find a different approach that works well, feel free
to share it. But please do not share code.</li><li class="li-enumerate">Note that these are just hints; you are welcome to use any
approach you like to solve this, as long as it is correct and runs
within the allowed time.</li></ol><!--TOC section id="sec7" Note Well:-->
<h2 id="sec7" class="section">Note Well:</h2><!--SEC END --><p>
<span style="font-weight:bold">This project is part of your final assessment, so cheating is not
acceptable. Any form of material exchange between teams, whether written,
electronic or any other medium, is considered cheating, and so is the
soliciting of help from electronic newsgroups. Providing undue assistance is
considered as serious as receiving it, and in the case of similarities that
indicate exchange of more than basic ideas, formal disciplinary action will
be taken for all involved parties. If you have questions regarding these
rules, please ask the lecturer.
</span></p><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</em><a href="http://hevea.inria.fr/index.html"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a><em>.</em></blockquote></body>
</html>
